package kdb

import (
	"bufio"
	"bytes"
	"reflect"
	"testing"
	"time"
)

// 0b
var BoolBytes = []byte{0x01, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0xff, 0x00}

// 01b
var BoolVecBytes = []byte{0x01, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x01}

// 8c6b8b64-6815-6084-0a3e-178401251b68
var GUIDBytes = []byte{0x01, 0x00, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00, 0xfe, 0x8c, 0x6b, 0x8b, 0x64, 0x68, 0x15, 0x60, 0x84, 0x0a, 0x3e, 0x17, 0x84, 0x01, 0x25, 0x1b, 0x68}

// 0x0 sv/: 16 cut `byte$til 32
var GUIDVecBytes = []byte{0x01, 0x00, 0x00, 0x00, 0x2e, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f}

// 1i
var IntBytes = []byte{0x01, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 0xfa, 0x01, 0x00, 0x00, 0x00}

// `GOOG
var SymbolBytes = []byte{0x01, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0xf5, 0x47, 0x4f, 0x4f, 0x47, 0x00}

// "GOOG"
var CharArrayBytes = []byte{0x01, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x04, 0x00, 0x00, 0x00, 0x47, 0x4f, 0x4f, 0x47}

// -8!2018.01.26D01:49:00.884361000
var TimestampAsBytes = []byte{0x01, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0xf4, 0x28, 0xbf, 0xce, 0x27, 0x35, 0xec, 0xe9, 0x07}
var TimestampAsTime = time.Date(2018, 1, 26, 1, 49, 0, 884361000, time.UTC)
var TimestampAsInt64 = int64(570246540884361000)
var DatetimeAsTime = time.Date(2013, 6, 10, 22, 03, 49, 713000000, time.UTC)
var DateAsTime = time.Date(2013, 6, 10, 0, 0, 0, 00000000, time.UTC)

func TestTimestampEpoch(t *testing.T) {
	d := TimestampAsTime
	if d.Sub(qEpoch).Nanoseconds() != TimestampAsInt64 {
		t.Error("Wrong epoch")
	}
}

// -8!(2018.01.26D01:49:00.884361000 2018.01.26D01:49:00.884361000)
var TimestampVectorAsBytes = []byte{0x01, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x02, 0x00, 0x00, 0x00, 0x28, 0xbf, 0xce, 0x27, 0x35, 0xec, 0xe9, 0x07, 0x28, 0xbf, 0xce, 0x27, 0x35, 0xec, 0xe9, 0x07}

// enlist 1i
var IntVectorBytes = []byte{0x01, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x06, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00}

// `byte$til 5
var ByteVectorBytes = []byte{0x01, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x04, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04}

//q)-8!0N!0D01:22:33.444555666*1+til 2
// 0D01:22:33.444555666 0D02:45:06.889111332
var TimespanVecBytes = []byte{0x01, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00,
	0x92, 0x9b, 0x4d, 0x50, 0x81, 0x04, 0x00, 0x00, 0x24, 0x37, 0x9b, 0xa0, 0x02, 0x09, 0x00, 0x00}

// 	q)-8!`abc`bc`c
var SymbolVectorBytes = []byte{0x01, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00, 0x0b,
	0x00, 0x03, 0x00, 0x00, 0x00, 0x61, 0x62, 0x63, 0x00, 0x62, 0x63, 0x00, 0x63, 0x00}

// -8!'type
var ErrorBytes = []byte{0x01, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x80, 0x74, 0x79, 0x70, 0x65, 0x00}

//
//q)-8!`a`b!2 3
var DictWithAtomsBytes = []byte{0x01, 0x00, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00,
	0x63, 0x0b, 0x00, 0x02, 0x00, 0x00, 0x00, 0x61, 0x00, 0x62, 0x00, 0x06, 0x00,
	0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00}

//-8!`s#`a`b!2 3
var SortedDictBytes = []byte{0x01, 0x00, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0x7f, 0x0b, 0x01, 0x02,
	0x00, 0x00, 0x00, 0x61, 0x00, 0x62, 0x00, 0x06,
	0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00}

//-8!`a`b!enlist each 2 3
var DictWithVectorsBytes = []byte{0x01, 0x00, 0x00, 0x00, 0x2d, 0x00, 0x00, 0x00, 0x63, 0x0b, 0x00, 0x02,
	0x00, 0x00, 0x00, 0x61, 0x00, 0x62, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
	0x06, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x06, 0x00, 0x01,
	0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00}

// ([]a:enlist 2;b:enlist 3)
var TableBytes = []byte{0x01, 0x00, 0x00, 0x00, 0x2f, 0x00, 0x00, 0x00, 0x62, 0x00, 0x63, 0x0b, 0x00, 0x02,
	0x00, 0x00, 0x00, 0x61, 0x00, 0x62, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x06, 0x00, 0x01,
	0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x06, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00}

//-8!`s#([]a:enlist 2;b:enlist 3)
var SortedTableBytes = []byte{0x01, 0x00, 0x00, 0x00, 0x2f, 0x00, 0x00, 0x00, 0x62, 0x01, 0x63, 0x0b, 0x00, 0x02, 0x00,
	0x00, 0x00, 0x61, 0x00, 0x62, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x06, 0x03, 0x01, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x06, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00}

// -8!([a:enlist 2]b:enlist 3)
var KeyedTableBytes = []byte{0x01, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x63, 0x62, 0x00, 0x63, 0x0b, 0x00, 0x01, 0x00,
	0x00, 0x00, 0x61, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x06, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02,
	0x00, 0x00, 0x00, 0x62, 0x00, 0x63, 0x0b, 0x00, 0x01, 0x00, 0x00, 0x00, 0x62, 0x00, 0x00, 0x00, 0x01, 0x00,
	0x00, 0x00, 0x06, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00}

// -8!`s#([a:enlist 2]b:enlist 3)
var SortedKeyedTableByes = []byte{0x01, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x7f, 0x62, 0x00, 0x63, 0x0b, 0x00, 0x01, 0x00,
	0x00, 0x00, 0x61, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x06, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02,
	0x00, 0x00, 0x00, 0x62, 0x00, 0x63, 0x0b, 0x00, 0x01, 0x00, 0x00, 0x00, 0x62, 0x00, 0x00, 0x00, 0x01, 0x00,
	0x00, 0x00, 0x06, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00}

// -8!{x+y}
var FuncBytes = []byte{0x01, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x64, 0x00, 0x0a,
	0x00, 0x05, 0x00, 0x00, 0x00, 0x7b, 0x78, 0x2b, 0x79, 0x7d}

//q)\d .d
//q.d)test:{x+y}
//q.d)-8!test
var FuncNonRootBytes = []byte{0x01, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x64, 0x64, 0x00, 0x0a,
	0x00, 0x05, 0x00, 0x00, 0x00, 0x7b, 0x78, 0x2b, 0x79, 0x7d}

// `byte$enlist til 5
var GeneralListBytes = []byte{0x01, 0x00, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04}

//q)-8!("ac";`b;`)
var GenericList2Bytes = []byte{0x01, 0x00, 0x00, 0x00, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x02, 0x00, 0x00, 0x00, 0x61, 0x63, 0xf5, 0x62, 0x00, 0xf5, 0x00}

//q)-8!1986.07.23D03:10:45.000639000 2013.06.10D20:49:14.999361000
var TimestampVecBytes = []byte{0x01, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x02, 0x00, 0x00, 0x00, 0x18, 0x92,
	0x00, 0xc6, 0xed, 0xe4, 0x1c, 0xfa, 0xe8, 0x6d, 0xff, 0x39, 0x12, 0x1b, 0xe3, 0x05}

// -8!2013.06m +til 3
var MonthVecBytes = []byte{0x01, 0x00, 0x00, 0x00, 0x1a, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x03, 0x00, 0x00, 0x00, 0xa1, 0x00,
	0x00, 0x00, 0xa2, 0x00, 0x00, 0x00, 0xa3, 0x00, 0x00, 0x00}

// -8!21:22*til 2
var MinuteVecBytes = []byte{0x01, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x11, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x05, 0x00, 0x00}

// -8!21:22:01 + 1 2
var SecondVecBytes = []byte{0x01, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x12, 0x00, 0x02, 0x00, 0x00, 0x00, 0x7a, 0x2c, 0x01, 0x00, 0x7b, 0x2c, 0x01, 0x00}

//-8!1#21:53:37.963
var TimeVecBytes = []byte{0x01, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x13, 0x00, 0x01, 0x00, 0x00, 0x00, 0xab, 0xaa, 0xb2, 0x04}

//-8!1#2013.06.10
var DateVecBytes = []byte{0x01, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x01, 0x00, 0x00, 0x00, 0x2d, 0x13, 0x00, 0x00}

//-8!1#2013.06.10T22:03:49.713
var DateTimeVecBytes = []byte{0x01, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x01, 0x00, 0x00, 0x00, 0xd6, 0x81, 0xe8, 0x58, 0xeb, 0x2d, 0xb3, 0x40}

func TestDecoding(t *testing.T) {
	if testing.Short() {
		t.Skip("skipping test in short mode.")
	}
	for _, tt := range encodingTests {
		// fmt.Println(tt.desc)
		r := bufio.NewReader(bytes.NewReader(tt.expected))
		d, _, err := Decode(r)
		if err != nil && tt.input.Type != KERR {
			t.Errorf("Decoding '%s' failed:%s", tt.desc, err)
			continue
		}
		if tt.input.Type == KERR {
			d = Error(err)
		}
		if !reflect.DeepEqual(d, tt.input) {
			t.Errorf("Decoded '%s' incorrectly. Expected '%#v', got '%#v'\n", tt.desc, tt.input, d)
		}
	}
}

func BenchmarkDecodeAll(b *testing.B) {
	for i := 0; i < b.N; i++ {
		for _, tt := range encodingTests {
			r := bufio.NewReader(bytes.NewReader(tt.expected))
			_, _, err := Decode(r)
			if err != nil && tt.input.Type != KERR {
				b.Errorf("Decoding '%s' failed:%s", tt.desc, err)
				continue
			}
		}
	}
}
